\label{entry:unixshelltips}

This section documents basic Unix commands and then some clever combinations for tasks we often encounter during research.
At the command line, type \texttt{man <<command>>} to get the \href{https://en.wikipedia.org/wiki/Man_page}{manual page} for \texttt{<<comand>>}.

\subsection{Mac OS X is Unix and POSIX-compliant, not GNU/Linux}

Mac OS X is based on the Darwin operating system, which is based on BSD.
It \href{https://www.opengroup.org/openbrand/register/apple.htm}{counts as UNIX} and is POSIX-compliant.
But it is not GNU/Linux. 
You will therefore run into annoying differences when trying to use some utilities, mostly when you see a solution on StackExchange that works on GNU/Linux but doesn't work on Mac OS X.
Here's a short list:
\begin{itemize}
\item \texttt{tree} not available in OS X
\item \texttt{cut} lacks the complement option in OS X
\item Unfortunately, \texttt{sed} differs considerably between GNU and OS X.
\begin{itemize}
	\item The \texttt{-i} option syntax \href{https://stackoverflow.com/questions/2320564/i-need-my-sed-i-command-for-in-place-editing-to-work-with-both-gnu-sed-and-bsd}{differs} between GNU and OS X
	\item GNU sed \href{https://unix.stackexchange.com/questions/13711/differences-between-sed-on-mac-osx-and-other-standard-sed}{supports} \texttt{\textbackslash|}, \texttt{\textbackslash+}, and \texttt{\textbackslash?} in regular expressions but OS X (and POSIX) don't.
	\item Other warnings (\href{https://unix.stackexchange.com/a/131940}{1},\href{https://stackoverflow.com/questions/1227174/sed-on-os-x-cant-seem-to-use-in-regexps}{2}), like the \texttt{-e} flag will give you extended regular expressions in OS X but isn't really compatible with Linux.
\end{itemize}


\end{itemize}


\subsection{Navigating the file system}

\begin{itemize}
	\item \texttt{pwd}: identify the ``present working directory''
	\item \texttt{cd}: ``change directory'' to the named destination (e.g., \texttt{cd <<destination>>})
	\item \texttt{ls -lht}: lists the current directory's contents. The \texttt{-lht} options list the files in detail, with human-readable file sizes, ordered by time last modified.
	\item \href{https://en.wikipedia.org/wiki/Command-line_completion}{tab completion}: You do not have to type a complete filename. Starting typing the file name and hit the \texttt{tab} key. Commands with long or difficult to spell filenames can be entered by typing the first few characters and pressing a completion key, which completes the command or filename.
	\item To recall a command from your \href{https://www.howtogeek.com/howto/44997/how-to-use-bash-history-to-improve-your-command-line-productivity/}{history}, type \texttt{ctrl-R} to search and type a fragment of the command
	\item hashtag comments: comments in the shell are set off by \texttt{\#}. add a comment to your command to tag it for easier retrieval via search in the future
	\item copy files using \texttt{cp}, move files using \texttt{mv}
	\item copy files across different servers using \href{https://kb.iu.edu/d/agye}{scp}
\end{itemize}

\subsection{Navigating text}

\begin{itemize}
	\item \texttt{ctrl-A} jumps to beginning of line
	\item \texttt{ctrl-E} jumps to end of line
	\item \texttt{ctrl-K} kills content (cuts) from cursor to end of line
	\item \texttt{ctrl-U} kills content (cuts) from cursor to beginning of line
\end{itemize}

\subsection{Piping and writing to file}
A \href{https://en.wikipedia.org/wiki/Pipeline_(Unix)}{pipeline} is a sequence of processes chained together by their standard streams, so that the output of each process feeds directly as input to the next one.
Pipe using \texttt{|}.

To write output to a file, use \texttt{>}.
This overwrites the file if it already exists.
Use \texttt{>>} to append to an existing file.


\begin{itemize}
	\item parse a directory listing using \texttt{grep}: the command 
	\begin{verbatim}ls -l | grep 'key'\end{verbatim}
	will output the directory listing and select only the lines containing the phrase ``key''
	\item write hello world to a file:
	\begin{verbatim}echo 'hello world' > file.txt\end{verbatim}
	\item look for missing files in a numbered sequence:
		  \begin{verbatim}
		  ls ../output/isoindices_{1..500}.dta > /dev/null
		  \end{verbatim}
		  This returns only the files that are not found in that \href{http://www.thelinuxrain.com/articles/building-sequences-of-numbers-on-the-command-line}{sequence}.
		  (the null device is a device file that discards all data written to it but reports that the write operation succeeded)
\end{itemize}

\subsection{Text processing}

\begin{itemize}
	\item \texttt{cat}: Reads files sequentially, writing them to standard output. The name is derived from its function to concatenate files. At the command line, think of this as ``print the file''.
	\item \texttt{head -n <filename>} outputs the first \texttt{n} lines of the file. the default is ten lines
	\item \texttt{tail -n <filename>} outputs the last \texttt{n} lines of the file. the default is ten lines
	\item \texttt{grep}: returns all lines of a file matching a specified expression (use \texttt{-v} option to return all lines not containing the expression)
	\begin{itemize}
		\item how to \href{https://stackoverflow.com/questions/29465612/how-to-detect-invalid-utf8-unicode-binary-in-a-text-file}{detect invalid utf8} unicode/binary in a text file: \texttt{grep -axv '.*' file.txt}
	\end{itemize}
	\item \texttt{sed}: stream editor with many functions; I mostly use it to substitute one expression for another
	\item \texttt{awk}: find and replace text, print columns, a number of other text editing functions
	\begin{itemize}
		\item \href{https://developer.ibm.com/tutorials/l-awk1/}{An intro to the great language with the strange name} (Daniel Robbins, 1 Dec 2000)
		\item \href{https://gregable.com/2010/09/why-you-should-know-just-little-awk.html}{Why you should learn just a little Awk} (Greg Grothaus, 29 Sep 2010)
	\end{itemize}
	\item \texttt{paste}: horizontally concatenate files with equal number of lines
\end{itemize}

Combine these well and you get something like 
``\href{https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html}{Command-line Tools can be 235x Faster than your Hadoop Cluster}''.

\subsection{Emacs}

Most often, you'll be an environment where you get to choose your own text editor.
However, in some (i.e., confidential) computing environments, you will not be free to install arbitrary software.
Emacs will typically be installed everywhere, so it it worth knowing some basic info.

\href{https://en.wikipedia.org/wiki/Emacs}{Emacs} is a family of text editors, dating to the 1970s, that is ``the extensible, customizable, self-documenting, real-time display editor.''
But there's a learning curve.
Even \href{https://www.gnu.org/software/emacs/tour/}{the introductions} can be overwhelming.

With regard to Emacs \href{https://www.emacswiki.org/emacs/EmacsKeyNotation}{key notation},
\texttt{C} means the ``control'' key and \texttt{M} means the alt/option key.

\begin{itemize}
	\item Quitting/exiting: \texttt{C-x C-c}
	\item Saving: \texttt{C-x C-s}
	\item \href{https://www.emacswiki.org/emacs/CopyAndPaste}{Copy and paste}: 
	The selected region is where your cursor is relative to where you set a mark.
	Set a mark with C-space.
	Then move your cursor to end of region and hit C-w to cut (kill) or M-w to copy.
	Paste using C-y (yank).

\end{itemize}

\subsection{Multiple ``windows''}

\href{https://www.gnu.org/software/screen/manual/}{Screen} is ``a full-screen window manager that multiplexes a physical terminal between several processes, typically interactive shells.''
Consider using this if you want, e.g., to run Stata interactively in the bottom half of your screen while working on your do file in a text editor in the top half.

\subsection{Slurm (Simple Linux Utility for Resource Management)}

Read the \href{https://rcc.uchicago.edu/docs/using-midway/index.html#batch-jobs}{RCC introduction} and then head over to the \href{https://slurm.schedmd.com/overview.html}{official documentation}.
This \href{https://slurm.schedmd.com/pdfs/summary.pdf}{two-page PDF} lists almost all the relevant commands you might need.

\begin{itemize}
	\item \texttt{sbatch}: this command submits jobs (\texttt{.sbatch} scripts) to the job scheduler on the cluster
	\item \texttt{sinteractive}: start an interactive session on the server
	\item \texttt{squeue --user=jdingel}: list running and queued jobs for the relevant users
	\item My preferred \texttt{squeue} command is the following:
	\begin{lstlisting}[language=bash]
	squeue --user=jdingel  --format="\%.17i \%.13P \%.20j \%.8u \%.8T \%.9M \%.9l \%.6D \%R" #jdjobs
	\end{lstlisting}
	This provides a good bit more information about each job.
	\item \texttt{rcchelp sinfo}: produce a summary of the partitions on Midway
	\item How to only see really costly jobs: 
	\begin{lstlisting}[language=bash]
	rcchelp usage --byjob | grep '[0-9][0-9][0-9]\.[0-9][0-9][[:blank:]]|'
	\end{lstlisting}
	Without options, \texttt{rcchelp usage --byjob} provides a complete history of job submissions.
	Piping it to grep to select only lines containing a number in the form \#\#\#.\#\# returns only jobs that used at least 100 service units.
\end{itemize}

\subsection{Jumping between MacOS GUI and Terminal}

A few tips if you're using Terminal on your Mac but not a 100\% command-line ninja:
\begin{itemize}
	\item You can drag the path of a Mac folder into Terminal (or Stata) by dragging the folder icon at the top of its Finder window into the Terminal prompt (\href{https://twitter.com/lukestein/status/1179792864630296578}{via Luke Stein})
	\item Typing \texttt{`open . `} in any directory in the Terminal will open that folder in the Finder (\href{https://twitter.com/FlorianOswald/status/1179779138892292096}{via Florian Oswald})
\end{itemize}

\subsection{Other resources}

\begin{itemize}
	\item \url{https://unix.stackexchange.com/questions/6/what-are-your-favorite-command-line-features-or-tricks}
	\item MIT's \href{https://hacker-tools.github.io/}{Hacker Tools} course
	\item UChicago \href{https://rcc.uchicago.edu/support-and-services/workshops-and-training}{RCC Workshops and Training}
\end{itemize}